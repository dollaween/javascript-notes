<div align="center">

# Sliding Window

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)
|
[Заметки](https://github.com/dollaween/javascript-notes)

</div>

---

Подходит для:
* Поиска диапазона и последовательности в массиве/строке

#### Реализация 1
1. Найдите изначальный подмассив.
2. В каждой новой итерации добавляйте элемент в конец и удаляйте элемент в начале.
3. Произведите перерасчет по формуле `window - значение_первого_элемента_window + следующее_значение`
4. Сравните новый расчет с предыдущим. Если новый расчет подходит лучше — замените им предыдущий.

```js
/**
 * Напишите функцию, которая принимает массив чисел nums и число n.
 * Функция должна вычислить максимальную сумму n-подряд идущих элементов в массиве.
 */
function maxSubarraySum(nums, n) {
  if (nums.length < n) {
    return null
  }

  // Сюда будет записан итоговый максимальный результат
  let max = 0

  // Переменная-помощник для хранения временных расчетов
  let temp = 0

  // Задаем изначальное окно (Sliding Window), которое будем двигать
  for (let i = 0; i < n; i++) {
    max += nums[i]
  }

  temp = max;
  for (let i = n; i < nums.length; i++) {
    // Производим перерасчет,
    // где temp — это window,
    // nums[i - n] — первый элемент window,
    // nums[i] — следующий элемент
    temp = temp - nums[i - n] + nums[i]

    // Сравниваем новый расчет с предыдущим
    max = Math.max(max, temp)
  }

  return max
}

maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 2)
// 10, так как максимальная сумма из двух подряд идущих элементов = 2 + 8

maxSubarraySum([1, 2, 5, 2, 8, 1, 5], 4)
// 17, так как максимальная сумма из четырех подряд идущих элементов = 2 + 5 + 2 + 8
```

Иллюстрация:
```js
 1  2  5  2  8  1  5

[1  2  5  2]
   [2  5  2  8]
      [5  2  8  1]
         [2  8  1  5]
```

Мы могли бы просто сделать цикл, в каждой итерации брать `n` элементов и сравнивать. Но что если `n` элементов — это не 2 или 3, а 1 000 000? Нам бы пришлось в каждой итерации пересчитывать 1 000 000 элементов.

В Sliding Window мы не пересчитываем значения элементов хранящихся в нем, а только удаляем значение первого элемента и добавляем значение нового. В каждой итерации имеем константное количество арифметических операций — 2.

#### Реализация 2: Гибкий Sliding Window
Отличия от прошлой реализации — ширина Sliding Window может изменяться в процессе. Для отслеживания начала и конца окна можно использовать паттерн Multiple Pointers.
1. Поставьте два указателя `a` и `b` на позиции `0 0` или `0 1`.
2. Установите случай выхода из цикла: когда указатель `a` равен длине массива или когда указатель `b`?
3. В каждой итерации либо расширяйте окно на `+1` элемент в конец, либо сужайте, удаляя самый первый.
4. Произведите перерасчет.
5. Сравните новый расчет с предыдущим.

Схематично реализация выглядит так:
```js
function name() {
  let result = 0      // итоговый результат
  let temp = 0        // временная переменная
  let a = 0           // указатель начала окна
  let b = 0           // указатель конца окна
  while () {
    if () {
      a++
    } else {
      b++
    }
  }
}
```

Пример:
```js
/**
 * Напишите функцию, которая принимает массив положительных чисел arr и число num.
 * Функция должна вернуть минимальную длину непрерывного подмассива
 * сумма которого больше или равна числу num.
 */
function minSubArrayLen(arr, num) {
  let a = 0   // start
  let b = 0   // end
  let sum = 0
  let min = Infinity

  while (a < arr.length) {
    if (sum < num && b < arr.length) {
      sum += arr[b]
      b++
    } else if (sum >= num) {
      min = Math.min(min, b - a)
      sum -= arr[a]
      a++
    } else {
      break
    }
  }

  return min === Infinity ? 0 : min
}

minSubArrayLen([2, 3, 1, 2, 4, 3], 7)
// 2, потому что [4, 3] — минимальный непрерывный подмассив, сумма чисел которого больше или равно 7

minSubArrayLen([2, 1, 6, 5, 4], 9)
// 2, потому что [5, 4] — минимальный непрерывный подмассив

minSubArrayLen([3, 1, 62, 19], 52)
// 1, потому что [62] — минимальный непрервный подмассив, который больше чем 52
```

Иллюстрация:
```js
[2] 3  1  2  4  3
[2  3] 1  2  4  3
[2  3  1] 2  4  3
[2  3  1  2] 4  3
 2 [3  1  2] 4  3
 2 [3  1  2  4] 3
 2  3 [1  2  4] 3
 2  3  1 [2  4  3]
 2  3  1  2 [4  3]
 2  3  1  2  4 [3]
```
