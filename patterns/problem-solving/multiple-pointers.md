<div align="center">

# Multiple Pointers

[Вопросы](https://github.com/dollaween/javascript-questions)
|
[Тесты](https://github.com/dollaween/javascript-tests)
|
[Задачи](https://github.com/dollaween/javascript-tasks)
|
[Заметки](https://github.com/dollaween/javascript-notes)

</div>

---

**Multiple Pointers** — это паттерн, при котором создаются несколько указателей, соответствующих индексу или позиции, и двигающихся по направлению к началу/концу/середине от начальной позиции. Паттерн крайне эффективен для решения задач с минимальной простраственной сложностью (space complexity).

Подходит для:
* Сравнивания/использования значений массива начиная одновременно из начала и конца
* Поиска/работы с подстрокой/подмассивом
* Слияния двух отсортированных массивов в один отсортированный

#### Реализация 1
1. При необходимости, отсортируйте массив
2. Создайте два указателя: на индексы 0 и 1.
3. Пройдитесь по массиву до конца, в каждой итерации передвигая индексы на +1.

```js
/**
 * Напишите функцию, которая принимает неограниченное количество аргументов
 * и возвращает false, если среди аргументов нет повторяющихся.
 */
function areThereDuplicates(...args) {
  args = args.sort()

  let a = 0
  let b = 1

  for (; b < args.length; a++, b++) {
    if (args[a] === args[b]) {
      return true
    }
  }

  return false
}

areThereDuplicates(1, 2, 3, 4)     // false
areThereDuplicates(1, 2, 3, 4, 1)  // true
```

Иллюстрация:
```js
// a b
// 1 2 3 4
// 
//   a b
// 1 2 3 4
//
//     a b
// 1 2 3 4
```

#### Реализация 2
1. При необходимости, отсортируйте массив
2. Создайте два указателя: на индексы 0 и length - 1.
3. Итерируйте массив увеличивая первый курсор на +1, а второй на -1 до тех пор, пока первый указатель не будет больше второго.

```js
/**
 * Напишите функцию, которая проверяет, что элементы в массиве `arr1`
 * содержатся в массиве `arr2` в том же порядке, но реверсивно
 */
function isItReverseArray(arr1, arr2) {
  if (arr1.length !== arr2.length) return false

  let a = 0
  let b = arr2.length - 1

  for (; a < arr1.length; a++, b--) {
    if (arr1[a] !== arr2[b]) {
      return false
    }
  }

  return true
}

isItReverseArray([1, 2, 3, 4], [4, 3, 2, 1])    // true
```

Иллюстрация:
```js
// a                 b
// 1 2 3 4  |  4 3 2 1
//
//   a             b
// 1 2 3 4  |  4 3 2 1
//
//     a         b
// 1 2 3 4  |  4 3 2 1
//
//       a     b
// 1 2 3 4  |  4 3 2 1
```

#### Реализация 3
1. При необходимости, отсортируйте массив.
2. Создайте два указателя со значением 0.
3. Двигайтесь по обоим массивам, увеличивая только один из указателей по условию в каждой итерации

```js
/**
 * Напишите функцию, которая принимает два отсортированных массива чисел.
 * Функция должна объединить два массива и вернуть отсортированный массив чисел.
 */
function mergeSortedArrays(nums1, nums2) {
  const result = []
  let i = 0
  let k = 0

  while (i < nums1.length && k < nums2.length) {
    if (nums1[i] < nums2[k]) {
      result.push(nums1[i])
      i++
    } else {
      result.push(nums2[k])
      k++
    }
  }

  while (i < nums1.length) {
    result.push(nums1[i])
    i++
  }

  while (k < nums2.length) {
    result.push(nums2[k])
    k++
  }

  return result
};

console.log(mergeSortedArrays([1, 5, 7], [0, 2]))
// [ 0, 1, 2, 5, 7 ]
```

Иллюстрация:
```js
// a         b
// 1 5 7  |  0 2
// 
// a           b
// 1 5 7  |  0 2
//
//   a         b
// 1 5 7  |  0 2
//
//   a
// 1 5 7  |  0 2
//
//     a
// 1 5 7  |  0 2
```



